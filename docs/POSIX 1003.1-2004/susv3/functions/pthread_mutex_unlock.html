<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css">
<!-- Generated by The Open Group's rhtm tool v1.2.1 -->
<!-- Copyright (c) 2001-2004 IEEE and The Open Group, All Rights Reserved -->
<title>pthread_mutex_lock</title>
</head>
<body bgcolor="white">
<script type="text/javascript" language="JavaScript" src="../jscript/codes.js">
</script>

<basefont size="3"> <a name="pthread_mutex_lock"></a> <a name="tag_03_540"></a><!-- pthread_mutex_lock -->
 <!--header start-->
<center><font size="2">The Open Group Base Specifications Issue 6<br>
IEEE Std 1003.1, 2004 Edition<br>
Copyright &copy; 2001-2004 The IEEE and The Open Group, All Rights reserved.</font></center>

<!--header end-->
<hr size="2" noshade>
<h4><a name="tag_03_540_01"></a>NAME</h4>

<blockquote>pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock - lock and unlock a mutex</blockquote>

<h4><a name="tag_03_540_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('THR')">THR</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/pthread.h.html">pthread.h</a>&gt;<br>
<br>
 int pthread_mutex_lock(pthread_mutex_t *</tt><i>mutex</i><tt>);<br>
 int pthread_mutex_trylock(pthread_mutex_t *</tt><i>mutex</i><tt>);<br>
 int pthread_mutex_unlock(pthread_mutex_t *</tt><i>mutex</i><tt>); <img src="../images/opt-end.gif" alt="[Option End]" border=
"0"></tt></code></div>

<tt><br>
</tt></blockquote>

<h4><a name="tag_03_540_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The mutex object referenced by <i>mutex</i> shall be locked by calling <i>pthread_mutex_lock</i>(). If the mutex is already
locked, the calling thread shall block until the mutex becomes available. This operation shall return with the mutex object
referenced by <i>mutex</i> in the locked state with the calling thread as its owner.</p>

<p><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock detection shall not be provided. Attempting to relock the mutex causes
deadlock. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, undefined behavior
results.</p>

<p>If the mutex type is PTHREAD_MUTEX_ERRORCHECK, then error checking shall be provided. If a thread attempts to relock a mutex
that it has already locked, an error shall be returned. If a thread attempts to unlock a mutex that it has not locked or a mutex
which is unlocked, an error shall be returned.</p>

<p>If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the mutex shall maintain the concept of a lock count. When a thread
successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the
lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When
the lock count reaches zero, the mutex shall become available for other threads to acquire. If a thread attempts to unlock a mutex
that it has not locked or a mutex which is unlocked, an error shall be returned.</p>

<p>If the mutex type is PTHREAD_MUTEX_DEFAULT, attempting to recursively lock the mutex results in undefined behavior. Attempting
to unlock the mutex if it was not locked by the calling thread results in undefined behavior. Attempting to unlock the mutex if it
is not locked results in undefined behavior. <img src="../images/opt-end.gif" alt="[Option End]" border="0"></p>

<p>The <i>pthread_mutex_trylock</i>() function shall be equivalent to <i>pthread_mutex_lock</i>(), except that if the mutex object
referenced by <i>mutex</i> is currently locked (by any thread, including the current thread), the call shall return immediately. If
the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex is currently owned by the calling thread, the mutex lock count shall be
incremented by one and the <i>pthread_mutex_trylock</i>() function shall immediately return success.</p>

<p>The <i>pthread_mutex_unlock</i>() function shall release the mutex object referenced by <i>mutex</i>. <sup>[<a href=
"javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0"> &nbsp;The manner
in which a mutex is released is dependent upon the mutex's type attribute. <img src="../images/opt-end.gif" alt="[Option End]"
border="0"> If there are threads blocked on the mutex object referenced by <i>mutex</i> when <i>pthread_mutex_unlock</i>() is
called, resulting in the mutex becoming available, the scheduling policy shall determine which thread shall acquire the mutex.</p>

<p><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
(In the case of PTHREAD_MUTEX_RECURSIVE mutexes, the mutex shall become available when the count reaches zero and the calling
thread no longer has any locks on this mutex.) <img src="../images/opt-end.gif" alt="[Option End]" border="0"></p>

<p>If a signal is delivered to a thread waiting for a mutex, upon return from the signal handler the thread shall resume waiting
for the mutex as if it was not interrupted.</p>
</blockquote>

<h4><a name="tag_03_540_04"></a>RETURN VALUE</h4>

<blockquote>
<p>If successful, the <i>pthread_mutex_lock</i>() and <i>pthread_mutex_unlock</i>() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.</p>

<p>The <i>pthread_mutex_trylock</i>() function shall return zero if a lock on the mutex object referenced by <i>mutex</i> is
acquired. Otherwise, an error number is returned to indicate the error.</p>
</blockquote>

<h4><a name="tag_03_540_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>pthread_mutex_lock</i>() and <i>pthread_mutex_trylock</i>() functions shall fail if:</p>

<dl compact>
<dt>[EINVAL]</dt>

<dd>The <i>mutex</i> was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's
priority is higher than the mutex's current priority ceiling.</dd>
</dl>

<p>The <i>pthread_mutex_trylock</i>() function shall fail if:</p>

<dl compact>
<dt>[EBUSY]</dt>

<dd>The <i>mutex</i> could not be acquired because it was already locked.</dd>
</dl>

<p>The <i>pthread_mutex_lock</i>(), <i>pthread_mutex_trylock</i>(), and <i>pthread_mutex_unlock</i>() functions may fail if:</p>

<dl compact>
<dt>[EINVAL]</dt>

<dd>The value specified by <i>mutex</i> does not refer to an initialized mutex object.</dd>

<dt>[EAGAIN]</dt>

<dd><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
The mutex could not be acquired because the maximum number of recursive locks for <i>mutex</i> has been exceeded. <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></dd>
</dl>

<p>The <i>pthread_mutex_lock</i>() function may fail if:</p>

<dl compact>
<dt>[EDEADLK]</dt>

<dd>A deadlock condition was detected or the current thread already owns the mutex.</dd>
</dl>

<p>The <i>pthread_mutex_unlock</i>() function may fail if:</p>

<dl compact>
<dt>[EPERM]</dt>

<dd>The current thread does not own the mutex.</dd>
</dl>

<p>These functions shall not return an error code of [EINTR].</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4><a name="tag_03_540_06"></a>EXAMPLES</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_540_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_540_08"></a>RATIONALE</h4>

<blockquote>
<p>Mutex objects are intended to serve as a low-level primitive from which other thread synchronization functions can be built. As
such, the implementation of mutexes should be as efficient as possible, and this has ramifications on the features available at the
interface.</p>

<p>The mutex functions and the particular default settings of the mutex attributes have been motivated by the desire to not
preclude fast, inlined implementations of mutex locking and unlocking.</p>

<p>For example, on systems not supporting the XSI extended mutex types, deadlocking on a double-lock is explicitly allowed behavior
in order to avoid requiring more overhead in the basic mechanism than is absolutely necessary. (More &quot;friendly&quot; mutexes that
detect deadlock or that allow multiple locking by the same thread are easily constructed by the user via the other mechanisms
provided. For example, <a href="../functions/pthread_self.html"><i>pthread_self</i>()</a> can be used to record mutex ownership.)
Implementations might also choose to provide such extended features as options via special mutex attributes.</p>

<p>Since most attributes only need to be checked when a thread is going to be blocked, the use of attributes does not slow the
(common) mutex-locking case.</p>

<p>Likewise, while being able to extract the thread ID of the owner of a mutex might be desirable, it would require storing the
current thread ID when each mutex is locked, and this could incur unacceptable levels of overhead. Similar arguments apply to a
<i>mutex_tryunlock</i> operation.</p>

<p>For further rationale on the XSI extended mutex types, see the Rationale (Informative) volume of
IEEE&nbsp;Std&nbsp;1003.1-2001.</p>
</blockquote>

<h4><a name="tag_03_540_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_540_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="pthread_mutex_destroy.html"><i>pthread_mutex_destroy</i>()</a>, <a href=
"pthread_mutex_timedlock.html"><i>pthread_mutex_timedlock</i>()</a>, the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, <a href="../basedefs/pthread.h.html"><i>&lt;pthread.h&gt;</i></a></p>
</blockquote>

<h4><a name="tag_03_540_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 5. Included for alignment with the POSIX Threads Extension.</p>
</blockquote>

<h4><a name="tag_03_540_12"></a>Issue 6</h4>

<blockquote>
<p>The <i>pthread_mutex_lock</i>(), <i>pthread_mutex_trylock</i>(), and <i>pthread_mutex_unlock</i>() functions are marked as part
of the Threads option.</p>

<p>The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:</p>

<ul>
<li>
<p>The behavior when attempting to relock a mutex is defined.</p>
</li>
</ul>

<p>The <a href="../functions/pthread_mutex_timedlock.html"><i>pthread_mutex_timedlock</i>()</a> function is added to the SEE ALSO
section for alignment with IEEE&nbsp;Std&nbsp;1003.1d-1999.</p>

<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XSH/TC2/D6/98 is applied, updating the ERRORS section so that the [EDEADLK]
error includes detection of a deadlock condition. The RATIONALE section is also reworded to take into account non-XSI-conformant
systems.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr size="2" noshade>
<center><font size="2"><!--footer start-->
UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../utilities/contents.html">XCU</a> | <a href="../functions/contents.html">XSH</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<!--footer end-->
<hr size="2" noshade>
</body>
</html>

