<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css">
<!-- Generated by The Open Group's rhtm tool v1.2.1 -->
<!-- Copyright (c) 2001-2004 IEEE and The Open Group, All Rights Reserved -->
<title>tdelete</title>
</head>
<body bgcolor="white">
<script type="text/javascript" language="JavaScript" src="../jscript/codes.js">
</script>

<basefont size="3"> <a name="tdelete"></a> <a name="tag_03_770"></a><!-- tdelete -->
 <!--header start-->
<center><font size="2">The Open Group Base Specifications Issue 6<br>
IEEE Std 1003.1, 2004 Edition<br>
Copyright &copy; 2001-2004 The IEEE and The Open Group, All Rights reserved.</font></center>

<!--header end-->
<hr size="2" noshade>
<h4><a name="tag_03_770_01"></a>NAME</h4>

<blockquote>tdelete, tfind, tsearch, twalk - manage a binary search tree</blockquote>

<h4><a name="tag_03_770_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/search.h.html">search.h</a>&gt;<br>
<br>
 void *tdelete(const void *restrict</tt> <i>key</i><tt>, void **restrict</tt> <i>rootp</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int(*</tt><i>compar</i><tt>)(const void *, const void *));<br>
 void *tfind(const void *</tt><i>key</i><tt>, void *const *</tt><i>rootp</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int(*</tt><i>compar</i><tt>)(const void *, const void *));<br>
 void *tsearch(const void *</tt><i>key</i><tt>, void **</tt><i>rootp</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*</tt><i>compar</i><tt>)(const void *, const void *));<br>
 void twalk(const void *</tt><i>root</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*</tt><i>action</i><tt>)(const void *, VISIT, int)); <img src="../images/opt-end.gif"
alt="[Option End]" border="0"></tt></code></div>

<tt><br>
</tt></blockquote>

<h4><a name="tag_03_770_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>tdelete</i>(), <i>tfind</i>(), <i>tsearch</i>(), and <i>twalk</i>() functions manipulate binary search trees. Comparisons
are made with a user-supplied routine, the address of which is passed as the <i>compar</i> argument. This routine is called with
two arguments, which are the pointers to the elements being compared. The application shall ensure that the user-supplied routine
returns an integer less than, equal to, or greater than 0, according to whether the first argument is to be considered less than,
equal to, or greater than the second argument. The comparison function need not compare every byte, so arbitrary data may be
contained in the elements in addition to the values being compared.</p>

<p>The <i>tsearch</i>() function shall build and access the tree. The <i>key</i> argument is a pointer to an element to be accessed
or stored. If there is a node in the tree whose element is equal to the value pointed to by <i>key</i>, a pointer to this found
node shall be returned. Otherwise, the value pointed to by <i>key</i> shall be inserted (that is, a new node is created and the
value of <i>key</i> is copied to this node), and a pointer to this node returned. Only pointers are copied, so the application
shall ensure that the calling routine stores the data. The <i>rootp</i> argument points to a variable that points to the root node
of the tree. A null pointer value for the variable pointed to by <i>rootp</i> denotes an empty tree; in this case, the variable
shall be set to point to the node which shall be at the root of the new tree.</p>

<p>Like <i>tsearch</i>(), <i>tfind</i>() shall search for a node in the tree, returning a pointer to it if found. However, if it is
not found, <i>tfind</i>() shall return a null pointer. The arguments for <i>tfind</i>() are the same as for <i>tsearch</i>().</p>

<p>The <i>tdelete</i>() function shall delete a node from a binary search tree. The arguments are the same as for <i>tsearch</i>().
The variable pointed to by <i>rootp</i> shall be changed if the deleted node was the root of the tree. The <i>tdelete</i>()
function shall return a pointer to the parent of the deleted node, or a null pointer if the node is not found.</p>

<p>The <i>twalk</i>() function shall traverse a binary search tree. The <i>root</i> argument is a pointer to the root node of the
tree to be traversed. (Any node in a tree may be used as the root for a walk below that node.) The argument <i>action</i> is the
name of a routine to be invoked at each node. This routine is, in turn, called with three arguments. The first argument shall be
the address of the node being visited. The structure pointed to by this argument is unspecified and shall not be modified by the
application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored
in the node. The second argument shall be a value from an enumeration data type:</p>

<pre>
<tt>typedef enum { preorder, postorder, endorder, leaf } VISIT;
</tt>
</pre>

<p>(defined in <a href="../basedefs/search.h.html"><i>&lt;search.h&gt;</i></a>), depending on whether this is the first, second, or
third time that the node is visited (during a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
third argument shall be the level of the node in the tree, with the root being level 0.</p>

<p>If the calling function alters the pointer to the root, the result is undefined.</p>
</blockquote>

<h4><a name="tag_03_770_04"></a>RETURN VALUE</h4>

<blockquote>
<p>If the node is found, both <i>tsearch</i>() and <i>tfind</i>() shall return a pointer to it. If not, <i>tfind</i>() shall return
a null pointer, and <i>tsearch</i>() shall return a pointer to the inserted item.</p>

<p>A null pointer shall be returned by <i>tsearch</i>() if there is not enough space available to create a new node.</p>

<p>A null pointer shall be returned by <i>tdelete</i>(), <i>tfind</i>(), and <i>tsearch</i>() if <i>rootp</i> is a null pointer on
entry.</p>

<p>The <i>tdelete</i>() function shall return a pointer to the parent of the deleted node, or a null pointer if the node is not
found.</p>

<p>The <i>twalk</i>() function shall not return a value.</p>
</blockquote>

<h4><a name="tag_03_770_05"></a>ERRORS</h4>

<blockquote>
<p>No errors are defined.</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4><a name="tag_03_770_06"></a>EXAMPLES</h4>

<blockquote>
<p>The following code reads in strings and stores structures containing a pointer to each string and a count of its length. It then
walks the tree, printing out the stored strings and their lengths in alphabetical order.</p>

<pre>
<tt>#include &lt;search.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
<br>
#define STRSZ    10000
#define NODSZ    500
<br>
struct node {      /* Pointers to these are stored in the tree. */
    char    *string;
    int     length;
};
<br>
char   string_space[STRSZ];  /* Space to store strings. */
struct node nodes[NODSZ];    /* Nodes to store. */
void  *root = NULL;          /* This points to the root. */
<br>
int main(int argc, char *argv[])
{
    char   *strptr = string_space;
    struct node    *nodeptr = nodes;
    void   print_node(const void *, VISIT, int);
    int    i = 0, node_compare(const void *, const void *);
<br>
    while (gets(strptr) != NULL &amp;&amp; i++ &lt; NODSZ)  {
        /* Set node. */
        nodeptr-&gt;string = strptr;
        nodeptr-&gt;length = strlen(strptr);
        /* Put node into the tree. */
        (void) tsearch((void *)nodeptr, (void **)&amp;root,
            node_compare);
        /* Adjust pointers, so we do not overwrite tree. */
        strptr += nodeptr-&gt;length + 1;
        nodeptr++;
    }
    twalk(root, print_node);
    return 0;
}
<br>
/*
 *  This routine compares two nodes, based on an
 *  alphabetical ordering of the string field.
 */
int
node_compare(const void *node1, const void *node2)
{
    return strcmp(((const struct node *) node1)-&gt;string,
        ((const struct node *) node2)-&gt;string);
}
<br>
/*
 *  This routine prints out a node, the second time
 *  twalk encounters it or if it is a leaf.
 */
void
print_node(const void *ptr, VISIT order, int level)
{
    const struct node *p = *(const struct node **) ptr;
<br>
    if (order == postorder || order == leaf)  {
        (void) printf("string = %s,  length = %d\n",
            p-&gt;string, p-&gt;length);
    }
}
</tt>
</pre>
</blockquote>

<h4><a name="tag_03_770_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>The <i>root</i> argument to <i>twalk</i>() is one level of indirection less than the <i>rootp</i> arguments to <i>tdelete</i>()
and <i>tsearch</i>().</p>

<p>There are two nomenclatures used to refer to the order in which tree nodes are visited. The <i>tsearch</i>() function uses
<b>preorder</b>, <b>postorder</b>, and <b>endorder</b> to refer respectively to visiting a node before any of its children, after
its left child and before its right, and after both its children. The alternative nomenclature uses <b>preorder</b>,
<b>inorder</b>, and <b>postorder</b> to refer to the same visits, which could result in some confusion over the meaning of
<b>postorder</b>.</p>
</blockquote>

<h4><a name="tag_03_770_08"></a>RATIONALE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_770_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_770_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="hcreate.html"><i>hcreate</i>()</a>, <a href="lsearch.html"><i>lsearch</i>()</a>, the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, <a href="../basedefs/search.h.html"><i>&lt;search.h&gt;</i></a></p>
</blockquote>

<h4><a name="tag_03_770_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>

<h4><a name="tag_03_770_12"></a>Issue 5</h4>

<blockquote>
<p>The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.</p>
</blockquote>

<h4><a name="tag_03_770_13"></a>Issue 6</h4>

<blockquote>
<p>The DESCRIPTION is updated to avoid use of the term &quot;must&quot; for application requirements.</p>

<p>The <b>restrict</b> keyword is added to the <i>tdelete</i>() prototype for alignment with the ISO/IEC&nbsp;9899:1999
standard.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr size="2" noshade>
<center><font size="2"><!--footer start-->
UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../utilities/contents.html">XCU</a> | <a href="../functions/contents.html">XSH</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<!--footer end-->
<hr size="2" noshade>
</body>
</html>

